import * as vscode from 'vscode';
import { Vulnerability } from '../services/aiService';

export class VulnerabilityDecorationProvider {
    private decorationTypes: Map<string, vscode.TextEditorDecorationType> = new Map();
    private activeDecorations: Map<string, vscode.DecorationOptions[]> = new Map();

    constructor() {
        this.initializeDecorationTypes();
    }

    private initializeDecorationTypes(): void {
        const severityConfigs = {
            critical: {
                backgroundColor: 'rgba(220, 38, 38, 0.2)',
                border: '2px solid rgba(220, 38, 38, 0.8)',
                borderRadius: '3px',
                after: {
                    contentText: 'üî¥',
                    color: '#dc2626',
                    fontWeight: 'bold',
                    margin: '0 0 0 10px'
                }
            },
            high: {
                backgroundColor: 'rgba(249, 115, 22, 0.2)',
                border: '2px solid rgba(249, 115, 22, 0.8)',
                borderRadius: '3px',
                after: {
                    contentText: 'üü†',
                    color: '#f97316',
                    fontWeight: 'bold',
                    margin: '0 0 0 10px'
                }
            },
            medium: {
                backgroundColor: 'rgba(234, 179, 8, 0.2)',
                border: '2px solid rgba(234, 179, 8, 0.8)',
                borderRadius: '3px',
                after: {
                    contentText: 'üü°',
                    color: '#eab308',
                    fontWeight: 'bold',
                    margin: '0 0 0 10px'
                }
            },
            low: {
                backgroundColor: 'rgba(59, 130, 246, 0.2)',
                border: '2px solid rgba(59, 130, 246, 0.8)',
                borderRadius: '3px',
                after: {
                    contentText: 'üîµ',
                    color: '#3b82f6',
                    fontWeight: 'bold',
                    margin: '0 0 0 10px'
                }
            }
        };

        for (const [severity, config] of Object.entries(severityConfigs)) {
            this.decorationTypes.set(severity, vscode.window.createTextEditorDecorationType(config));
        }
    }

    updateDecorations(document: vscode.TextDocument, vulnerabilities: Vulnerability[]): void {
        const editor = vscode.window.visibleTextEditors.find(
            e => e.document === document
        );

        if (!editor) {
            return;
        }

        // Clear existing decorations
        this.clearDecorations(editor);

        // Group vulnerabilities by severity
        const vulnerabilitiesBySeverity = this.groupVulnerabilitiesBySeverity(vulnerabilities);

        // Apply decorations for each severity
        for (const [severity, vulns] of Object.entries(vulnerabilitiesBySeverity)) {
            const decorationType = this.decorationTypes.get(severity);
            if (!decorationType) {
                continue;
            }

            const decorations: vscode.DecorationOptions[] = vulns.map(vuln => {
                const line = vuln.line - 1; // Convert to 0-based indexing
                const lineLength = editor.document.lineAt(line).text.length;

                const range = new vscode.Range(
                    line,
                    0,
                    line,
                    lineLength
                );

                return {
                    range,
                    hoverMessage: new vscode.MarkdownString(this.createHoverMessage(vuln))
                };
            });

            editor.setDecorations(decorationType, decorations);
            this.activeDecorations.set(severity, decorations);
        }
    }

    clearDecorations(editor: vscode.TextEditor): void {
        for (const decorationType of this.decorationTypes.values()) {
            editor.setDecorations(decorationType, []);
        }
        this.activeDecorations.clear();
    }

    private groupVulnerabilitiesBySeverity(vulnerabilities: Vulnerability[]): Record<string, Vulnerability[]> {
        const grouped: Record<string, Vulnerability[]> = {
            critical: [],
            high: [],
            medium: [],
            low: []
        };

        for (const vuln of vulnerabilities) {
            if (grouped[vuln.severity]) {
                grouped[vuln.severity].push(vuln);
            }
        }

        return grouped;
    }

    private createHoverMessage(vulnerability: Vulnerability): string {
        const severityEmoji = {
            critical: 'üî¥',
            high: 'üü†',
            medium: 'üü°',
            low: 'üîµ'
        };

        const statusIcon = {
            detected: '‚ö†Ô∏è',
            analyzing: 'ü§ñ',
            fixed: '‚úÖ',
            failed: '‚ùå'
        };

        let message = `## ${severityEmoji[vulnerability.severity]} ${vulnerability.type}\n\n`;
        message += `**Severity:** ${vulnerability.severity.toUpperCase()}\n`;
        message += `**Line:** ${vulnerability.line}\n`;
        message += `**Status:** ${statusIcon[vulnerability.status]} ${vulnerability.status}\n\n`;
        message += `**Description:**\n${vulnerability.description}\n\n`;

        if (vulnerability.confidence) {
            message += `**AI Confidence:** ${vulnerability.confidence}%\n\n`;
        }

        if (vulnerability.suggestedFix) {
            message += `**Suggested Fix:**\n${vulnerability.suggestedFix}\n\n`;
        }

        if (vulnerability.aiFix) {
            message += `**AI Analysis:**\n${vulnerability.aiFix}\n\n`;
        }

        message += `---\n`;
        message += `[Apply AI Fix](command:sast.fixVulnerability?${encodeURIComponent(JSON.stringify(vulnerability))}) | [View Details](command:sast.openDashboard)`;

        return message;
    }

    dispose(): void {
        for (const decorationType of this.decorationTypes.values()) {
            decorationType.dispose();
        }
        this.decorationTypes.clear();
        this.activeDecorations.clear();
    }
}