import * as vscode from 'vscode';
import { Vulnerability } from '../services/aiService';

export class VulnerabilityProvider implements vscode.TreeDataProvider<VulnerabilityItem> {
    private _onDidChangeTreeData: vscode.EventEmitter<VulnerabilityItem | undefined | null | void> = new vscode.EventEmitter<VulnerabilityItem | undefined | null | void>();
    readonly onDidChangeTreeData: vscode.Event<VulnerabilityItem | undefined | null | void> = this._onDidChangeTreeData.event;

    private vulnerabilities: Map<string, Vulnerability[]> = new Map();
    private _extensionUri: vscode.Uri;

    constructor(extensionUri: vscode.Uri) {
        this._extensionUri = extensionUri;
    }

    refresh(): void {
        this._onDidChangeTreeData.fire();
    }

    getTreeItem(element: VulnerabilityItem): vscode.TreeItem {
        return element;
    }

    getChildren(element?: VulnerabilityItem): Thenable<VulnerabilityItem[]> {
        if (!element) {
            // Root level - show files with vulnerabilities
            const fileItems: VulnerabilityItem[] = [];
            
            for (const [filePath, fileVulnerabilities] of this.vulnerabilities) {
                const criticalCount = fileVulnerabilities.filter(v => v.severity === 'critical').length;
                const highCount = fileVulnerabilities.filter(v => v.severity === 'high').length;
                
                const item = new VulnerabilityItem(
                    vscode.Uri.parse(filePath),
                    `${vscode.Uri.parse(filePath).fsPath.split('/').pop()} (${criticalCount}C, ${highCount}H)`,
                    vscode.TreeItemCollapsibleState.Expanded,
                    'file'
                );
                
                item.contextValue = 'file';
                item.tooltip = `${fileVulnerabilities.length} vulnerabilities found`;
                fileItems.push(item);
            }
            
            return Promise.resolve(fileItems);
        } else {
            // File level - show vulnerabilities
            const filePath = element.resourceUri?.toString();
            if (!filePath) {
                return Promise.resolve([]);
            }

            const fileVulnerabilities = this.vulnerabilities.get(filePath) || [];
            const vulnerabilityItems = fileVulnerabilities.map(vuln => {
                const item = new VulnerabilityItem(
                    element.resourceUri,
                    `${vuln.type} - Line ${vuln.line}`,
                    vscode.TreeItemCollapsibleState.None,
                    'vulnerability'
                );
                
                item.contextValue = 'vulnerability';
                item.tooltip = `${vuln.description}\nConfidence: ${vuln.confidence}%`;
                item.command = {
                    command: 'vscode.open',
                    title: 'Open File',
                    arguments: [element.resourceUri, { selection: new vscode.Range(vuln.line - 1, 0, vuln.line - 1, 0) }]
                };
                
                // Set icon based on severity
                item.iconPath = this.getSeverityIcon(vuln.severity);
                
                // Store vulnerability data for context menu
                item.vulnerability = vuln;
                
                return item;
            });

            return Promise.resolve(vulnerabilityItems);
        }
    }

    updateVulnerabilities(uri: vscode.Uri, vulnerabilities: Vulnerability[]): void {
        const uriString = uri.toString();
        
        if (vulnerabilities.length === 0) {
            this.vulnerabilities.delete(uriString);
        } else {
            this.vulnerabilities.set(uriString, vulnerabilities);
        }
        
        this.refresh();
    }

    getAllVulnerabilities(): Vulnerability[] {
        const allVulns: Vulnerability[] = [];
        
        for (const fileVulns of this.vulnerabilities.values()) {
            allVulns.push(...fileVulns);
        }
        
        return allVulns;
    }

    getVulnerabilitiesForFile(uri: vscode.Uri): Vulnerability[] {
        return this.vulnerabilities.get(uri.toString()) || [];
    }

    private getSeverityIcon(severity: string): vscode.Uri {
        const iconMap: Record<string, string> = {
            'critical': 'critical.svg',
            'high': 'high.svg',
            'medium': 'medium.svg',
            'low': 'low.svg'
        };

        const iconName = iconMap[severity] || 'default.svg';
        return vscode.Uri.joinPath(this._extensionUri, 'resources', 'icons', iconName);
    }
}

export class VulnerabilityItem extends vscode.TreeItem {
    public vulnerability?: Vulnerability;

    constructor(
        public readonly resourceUri: vscode.Uri | undefined,
        public readonly label: string,
        public readonly collapsibleState: vscode.TreeItemCollapsibleState,
        public readonly itemType: 'file' | 'vulnerability'
    ) {
        super(label, collapsibleState);
    }
}